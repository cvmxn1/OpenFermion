#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
'''Functions to generate example phase functions quickly'''

from typing import Optional
import numpy


def make_phase_function(times: numpy.ndarray,
                        energies: numpy.ndarray,
                        amplitudes: numpy.ndarray,
                        repetitions: Optional[int] = None,
                        rng: Optional[numpy.random.RandomState] = None):
    '''Generates a phase function over the given set of data

    generates a function of the form g(t) = sum_jA_je^{iE_jt}
    for given values of t, A_j, E_j. Adds sampling noise further
    to this function as if it were generated by a quantum computer
    sampling from 0.5 (1 - Re[g(t)]) and 0.5 (1 - Im[g(t)]).

    Arguments:
        times [numpy.ndarray] -- times t to generate g(t) at
        energies [numpy.ndarray] -- values of E_j in the above
        amplitudes [numpy.ndarray] -- values of A_j in the above
        repetitions [int or None] -- number of samples to draw
            in the simulated sampling noise. If None, does not add
            sampling noise (effectively infinite samples)
    '''
    phase_function = amplitudes @ numpy.exp(
        1j * energies[:, numpy.newaxis] @ times[numpy.newaxis, :])
    if repetitions is None:
        return phase_function

    prob_r = 0.5 * (1 - numpy.real(phase_function))
    prob_i = 0.5 * (1 - numpy.imag(phase_function))

    if rng is None:
        rng = numpy.random

    est_r = rng.binomial(repetitions, prob_r) / repetitions
    est_i = rng.binomial(repetitions, prob_i) / repetitions

    phase_function = 1 - 2 * est_r + 1j - 2j * est_i
    return phase_function
